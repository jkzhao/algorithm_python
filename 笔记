程序=数据结构+算法

查找、排序

递归：
	1.调用自身
	2.结束条件


时间复杂度：
	常见的时间复杂度（按效率排序）：
		O(1) < O(logn) < O(n) < O(nlogn) < O(n2) < O(n2logn) < O(n3)
		O(logn): 多项式级别的时间复杂度，以2为底n的对数
	不常见的时间复杂度：
		O(n!) O(2n) O(nn) ...

	如何一眼判断时间复杂度？
		循环减半的过程 ——> O(logn)
		几层循环就是n的几次方的复杂度

空间复杂度：用来估算算法内存占用大小的一个式子

	空间换时间


查找：
	列表查找：从列表中查找指定元素。list.index(7)，输出该元素的下标。这个实现的就是顺序查找
		顺序（线性）查找：从列表中第一个元素开始，顺序进行搜索，直到找到为止  --O(n)
		二分查找：从“有序”列表的候选区 data[0:n] 开始，通过对待查找的值与候选区中间值的比较，可以使候选区减少一半。--O(logn)
			如果不是有序，你还想用二分，就得先排序，排序的时间复杂度最快是O(nlogn)。所以如果只查一次，肯定是上面的好，但是如果这个列表要反复查很多次，不如就先排好序，然后用二分
			二分查找还可以递归来写。


排序：
	列表排序：将无序列表变为有序列表
	应用场景：
	    各种榜单
	    各种表格
	    给二分查找用
	    给其他算法用

    排序low B三人组：
        冒泡排序
        选择排序
        插入排序
    排序NB三人组：
        快速排序
        堆排序
        归并排序
    没什么人用的排序：
        基数排序
        希尔排序
        桶排序


    【排序low B三人组】：
        1.冒泡排序
        2.选择排序
        3.插入排序

        算法关键点：
            有序区
            无序区

        1.冒泡排序思想：列表每两个相邻的元素，如果前面的比后面的大，那么交换这两个数。一趟排序，会把最大的数排到最后面。所以现在无序区就少了一个。
            需要走n-1趟，最后一趟也就是第n趟不用走了。
            代码关键点：
                趟
                无序区
            冒泡排序改进版：没什么大用
                如果冒泡排序中执行一趟没有交换，则列表已经是有序状态，可以直接结束算法

        2.选择排序
            思想：一趟遍历记录中最小的数，放到原来列表的第一个位置(和第一个位置的数进行交换)；再一趟遍历记录剩余列表中最小的数，继续放置；。。。
            问题是：怎么选出最小的数？
            代码关键点：
                无序区
                最小数的位置

        3.插入排序
            思想：列表被分为有序区和无序区两部分，最初有序区只有一个元素。每次从无序区选择一个元素，插入到有序区的位置，知道无序区变空
            很类似打牌时，手里有牌，然后抓了一张牌回来，插入到手中某个位置
            代码关键点：
                摸到的牌
                手里的牌

        总结下Low B三人组：
            时间复杂度：O(n2)
            空间复杂度：O(1)，都没有开辟新列表，都是在原列表上动手


    【排序NB三人组】：
        1.快速排序：快
            好写的排序算法里最快的 --NB三人组里也是最快的，时间复杂度都是一样的，但是时间上一般三者是最快的。
            快的排序算法里最好写的

            思路：
                （1）取一个元素p（第一个元素），使元素p归位；
                （2）使得列表被p分成两部分，左边都比p小，右边都比p大；
                （3）递归完成排序

                排序前： 5 7 4 6 3 1 2 9 8
                p归位：  2 1 4 3 5 6 7 9 8
                目标：   1 2 3 4 5 6 7 8 9

            代码关键点：
                归位
                递归

            问题：
                最坏情况：见代码
                    如何避免？不取第一个元素，随机取一个元素，partition第一步随机在left和right取一个元素，先与left位置的元素互换，然后在继续下面的操作
                            这样还是有可能存在最坏的情况，只是最坏的情况没法设计出来了
                递归深度
                    空间上开销比较大

        2.堆排序
            树和二叉树
            树是一种数据结构，比如：目录结构。树是一种可以递归定义的数据结构。
            树是由n个节点组成的集合：
                如果n=0，那这是一棵空树；
                如果n>0，那存在1个节点作为树的根节点，其他节点可以分为m个集合，每个集合本身又是一棵树
            概念：
                根节点（最上面的那个）、叶子节点(不再往下分的)
                树的深度(高度)
                节点的度：节点往下分了几叉
                树的度：所有节点的度的最大值
                孩子节点/父节点/祖先节点
                子树

            二叉树：
                度不超过2的树（节点最多有两个叉，左孩子节点和右孩子节点）

                两种特殊的二叉树：
                    满二叉树：除了叶子节点，所有节点都有两个孩子；并且所有叶子节点都在同一层面上。
                    完全二叉树：从满二叉树后面拿走部分节点。对于一棵具有 n 个节点的二叉树按层序编号,
                                如果编号为 i ( 1<= i <= n)的节点与同样深度的满二叉树中编号为 i 的节点在二叉树中位置完全相同,则这棵二叉树成为完全二叉树.

                满二叉树的特点:
                    (1) 满二叉树的叶子只能出现在最下一层,出现在其它层就不可能达成平衡.
                    (2) 非叶子节点的度一定是2.
                    (3) 在同样深度的二叉树中,满二叉树的节点个数最多,叶子数最多.

                完全二叉树的特点:
                    (1) 完全二叉树的叶子节点只能出现在最下面的两层.
                    (2) 最下层的叶子一定集中在左部的连续位置.
                    (3) 倒数二层,若有叶子节点,则一定在右部的连续位置
                    (4) 如果结点度为1,则该结点只有有孩子,即不存在只有右子树的情况.
                    (5) 同样结点数的二叉树,完全二叉树的深度最小.


                完全二叉树的存储方式
                    链式存储方式
                    顺序存储方法（列表）：从根节点开始，每层从左到右依次存节点的号码存进列表

                    最常见的操作：父亲找孩子 孩子找父亲
                        父节点和左孩子节点的编号下标(就是存进列表后，所在位置的下标)有什么关系？
                           i ——> 2i+1
                        父节点和右孩子节点的编号下标有什么关系？
                           i ——> 2i+2

            堆：特殊的完全二叉树
                大根(顶)堆：一棵完全二叉树，满足任一节点都比其孩子节点大
                小根(顶)堆：一棵完全二叉树，满足任一节点都比其孩子节点小

                大根堆：可以理解为一级一级领导机构，省长 县长 村长 民

                堆排序过程：（以大顶堆为例，升序）
                    1.建立堆

                    2.得到堆顶元素，为最大元素
                    3.去掉堆顶，将堆最后一个元素放到堆顶，此时可通过一次调整重新使堆有序
                    4.堆顶元素为第二大元素
                    5.重复步骤3，直到堆为空

                        第2步，去掉堆顶元素省长。
                        第3步，省长退位，始终是把最下层的最右边的叶子节点挪到堆顶，此时节点的左右子树都是堆，但自身不是堆，因为现在是个民在省长位置，他小于自己的孩子
                        此时可以通过一次向下的"调整"来将其变换成一个堆。

                        调整的过程是：把强行推上省长的那个节点拿下来，把大的县长提拔上来当省长，然后看看叶子节点能不能再下一级行政机构当县长，不能就继续向下；

                        第1步：构造堆
                            先调整最右下角的村，全部村调整完；
                            调整县级别
                            调整省级别

                        第2步：挨个出数


