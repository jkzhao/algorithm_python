程序=数据结构+算法

查找、排序

递归：
	1.调用自身
	2.结束条件


时间复杂度：
	常见的时间复杂度（按效率排序）：
		O(1) < O(logn) < O(n) < O(nlogn) < O(n2) < O(n2logn) < O(n3)
		O(logn): 多项式级别的时间复杂度，以2为底n的对数
	不常见的时间复杂度：
		O(n!) O(2n) O(nn) ...

	如何一眼判断时间复杂度？
		循环减半的过程 ——> O(logn)
		几层循环就是n的几次方的复杂度

空间复杂度：用来估算算法内存占用大小的一个式子

	空间换时间


查找：
	列表查找：从列表中查找指定元素。list.index(7)，输出该元素的下标。这个实现的就是顺序查找
		顺序（线性）查找：从列表中第一个元素开始，顺序进行搜索，直到找到为止  --O(n)
		二分查找：从“有序”列表的候选区 data[0:n] 开始，通过对待查找的值与候选区中间值的比较，可以使候选区减少一半。--O(logn)
			如果不是有序，你还想用二分，就得先排序，排序的时间复杂度最快是O(nlogn)。所以如果只查一次，肯定是上面的好，但是如果这个列表要反复查很多次，不如就先排好序，然后用二分
			二分查找还可以递归来写。


排序：
	列表排序：将无序列表变为有序列表
	应用场景：
	    各种榜单
	    各种表格
	    给二分查找用
	    给其他算法用

    排序low B三人组：
        冒泡排序
        选择排序
        插入排序
    排序NB三人组：
        快速排序
        堆排序
        归并排序
    没什么人用的排序：
        基数排序
        希尔排序
        桶排序


    【排序low B三人组】：
        1.冒泡排序
        2.选择排序
        3.插入排序

        算法关键点：
            有序区
            无序区

        1.冒泡排序思想：列表每两个相邻的元素，如果前面的比后面的大，那么交换这两个数。一趟排序，会把最大的数排到最后面。所以现在无序区就少了一个。
            需要走n-1趟，最后一趟也就是第n趟不用走了。
            代码关键点：
                趟
                无序区
            冒泡排序改进版：没什么大用
                如果冒泡排序中执行一趟没有交换，则列表已经是有序状态，可以直接结束算法

        2.选择排序
            思想：一趟遍历记录中最小的数，放到原来列表的第一个位置(和第一个位置的数进行交换)；再一趟遍历记录剩余列表中最小的数，继续放置；。。。
            问题是：怎么选出最小的数？
            代码关键点：
                无序区
                最小数的位置

        3.插入排序
            思想：列表被分为有序区和无序区两部分，最初有序区只有一个元素。每次从无序区选择一个元素，插入到有序区的位置，知道无序区变空
            很类似打牌时，手里有牌，然后抓了一张牌回来，插入到手中某个位置
            代码关键点：
                摸到的牌
                手里的牌

        总结下Low B三人组：
            时间复杂度：O(n2)
            空间复杂度：O(1)，都没有开辟新列表，都是在原列表上动手


    【排序NB三人组】：
        1.快速排序：快
            好写的排序算法里最快的 --NB三人组里也是最快的，时间复杂度都是一样的，但是时间上一般三者是最快的
            快的排序算法里最好写的

            思路：
                （1）取一个元素p（第一个元素），使元素p归位；
                （2）使得列表被p分成两部分，左边都比p小，右边都比p大；
                （3）递归完成排序

                排序前： 5 7 4 6 3 1 2 9 8
                p归位：  2 1 4 3 5 6 7 9 8
                目标：   1 2 3 4 5 6 7 8 9

            代码关键点：
                归位
                递归

            问题：
                最坏情况：见代码
                    如何避免？不取第一个元素，随机取一个元素，partition第一步随机在left和right取一个元素，先与left位置的元素互换，然后在继续下面的操作
                            这样还是有可能存在最坏的情况，只是最坏的情况没法设计出来了
                递归深度
                    空间上开销比较大






